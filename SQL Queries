-- Enable pgcrypto for UUID generation (optional but recommended)
create extension if not exists "pgcrypto";

-- Create user_profiles table (independent of Supabase Auth)
create table public.user_profiles (
  id uuid primary key default gen_random_uuid(),
  first_name text not null,
  last_name text not null,
  email text not null unique,
  password text not null,
  company text,
  created_at timestamp with time zone default timezone('Asia/Kolkata', now())
);

-- Enable Row Level Security (optional — for fine-grained access control)
alter table public.user_profiles enable row level security;

-- Basic policies (for manual control — allow everyone for now)
create policy "Allow read access to all"
on public.user_profiles
for select
using (true);

create policy "Allow insert to all"
on public.user_profiles
for insert
with check (true);


<===========================================>


-- -- Recreate login_logs without FK
create table public.login_logs (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references public.user_profiles(id) on delete cascade,
  login_time timestamp with time zone default timezone('Asia/Kolkata', now()),
  ip_address text,
  user_agent text
);

-- Enable Row Level Security (optional — for fine-grained access control)
alter table public.login_logs enable row level security;

create policy "Allow insert to all"
on public.login_logs
for insert
with check (true);



<===========================================>



/*
  # User Profiles and Authentication

  1. New Tables
    - `user_profiles`
      - `id` (uuid, references auth.users)
      - `first_name` (text)
      - `last_name` (text) 
      - `company` (text)
      - `job_title` (text)
      - `team_size` (text)
      - `avatar_url` (text)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `user_profiles` table
    - Add policies for users to manage their own profiles
*/

-- Create user profiles table
CREATE TABLE IF NOT EXISTS user_profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  first_name text,
  last_name text,
  company text,
  email text not null unique,
  job_title text,
  team_size text,
  avatar_url text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view own profile"
  ON user_profiles
  FOR SELECT
  TO authenticated
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON user_profiles
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile"
  ON user_profiles
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = id);

-- Create function to handle user profile creation
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO user_profiles (id, first_name, last_name)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'first_name', ''),
    COALESCE(new.raw_user_meta_data->>'last_name', '')
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for new user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_user_profiles_updated_at
  BEFORE UPDATE ON user_profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();


/*
  # Meetings Table

  1. New Tables
    - `meetings`
      - `id` (uuid, primary key)
      - `user_id` (uuid, references user_profiles)
      - `title` (text)
      - `description` (text)
      - `status` (text) - 'scheduled', 'in_progress', 'completed', 'cancelled'
      - `start_time` (timestamp)
      - `end_time` (timestamp)
      - `duration_minutes` (integer)
      - `participant_count` (integer)
      - `meeting_url` (text)
      - `recording_url` (text)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `meetings` table
    - Add policies for users to manage their own meetings
*/

-- Create meetings table
CREATE TABLE IF NOT EXISTS meetings (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL,
  title text NOT NULL,
  description text DEFAULT '',
  status text DEFAULT 'scheduled' CHECK (status IN ('scheduled', 'in_progress', 'completed', 'cancelled')),
  start_time timestamptz,
  end_time timestamptz,
  duration_minutes integer DEFAULT 0,
  participant_count integer DEFAULT 1,
  meeting_url text,
  recording_url text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE meetings ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view own meetings"
  ON meetings
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create own meetings"
  ON meetings
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own meetings"
  ON meetings
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own meetings"
  ON meetings
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

-- Create updated_at trigger
CREATE TRIGGER update_meetings_updated_at
  BEFORE UPDATE ON meetings
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_meetings_user_id ON meetings(user_id);
CREATE INDEX IF NOT EXISTS idx_meetings_status ON meetings(status);
CREATE INDEX IF NOT EXISTS idx_meetings_start_time ON meetings(start_time);


/*
  # Meeting Transcripts

  1. New Tables
    - `transcripts`
      - `id` (uuid, primary key)
      - `meeting_id` (uuid, references meetings)
      - `content` (text) - full transcript content
      - `speaker_segments` (jsonb) - array of speaker segments
      - `language` (text)
      - `confidence_score` (decimal)
      - `word_count` (integer)
      - `processing_status` (text)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `transcripts` table
    - Add policies based on meeting ownership
*/

-- Create transcripts table
CREATE TABLE IF NOT EXISTS transcripts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  meeting_id uuid REFERENCES meetings(id) ON DELETE CASCADE NOT NULL,
  content text NOT NULL DEFAULT '',
  speaker_segments jsonb DEFAULT '[]'::jsonb,
  language text DEFAULT 'en-US',
  confidence_score decimal(5,4) DEFAULT 0.0,
  word_count integer DEFAULT 0,
  processing_status text DEFAULT 'pending' CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed')),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE transcripts ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view transcripts of own meetings"
  ON transcripts
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = transcripts.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create transcripts for own meetings"
  ON transcripts
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = transcripts.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update transcripts of own meetings"
  ON transcripts
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = transcripts.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

-- Create updated_at trigger
CREATE TRIGGER update_transcripts_updated_at
  BEFORE UPDATE ON transcripts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_transcripts_meeting_id ON transcripts(meeting_id);
CREATE INDEX IF NOT EXISTS idx_transcripts_processing_status ON transcripts(processing_status);


/*
  # Meeting Summaries

  1. New Tables
    - `summaries`
      - `id` (uuid, primary key)
      - `meeting_id` (uuid, references meetings)
      - `summary_text` (text)
      - `key_points` (jsonb) - array of key discussion points
      - `decisions_made` (jsonb) - array of decisions
      - `next_steps` (jsonb) - array of next steps
      - `summary_type` (text) - 'brief', 'detailed', 'executive'
      - `ai_model_used` (text)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `summaries` table
    - Add policies based on meeting ownership
*/

-- Create summaries table
CREATE TABLE IF NOT EXISTS summaries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  meeting_id uuid REFERENCES meetings(id) ON DELETE CASCADE NOT NULL,
  summary_text text NOT NULL DEFAULT '',
  key_points jsonb DEFAULT '[]'::jsonb,
  decisions_made jsonb DEFAULT '[]'::jsonb,
  next_steps jsonb DEFAULT '[]'::jsonb,
  summary_type text DEFAULT 'brief' CHECK (summary_type IN ('brief', 'detailed', 'executive')),
  ai_model_used text DEFAULT 'gpt-3.5-turbo',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE summaries ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view summaries of own meetings"
  ON summaries
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = summaries.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create summaries for own meetings"
  ON summaries
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = summaries.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update summaries of own meetings"
  ON summaries
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = summaries.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

-- Create updated_at trigger
CREATE TRIGGER update_summaries_updated_at
  BEFORE UPDATE ON summaries
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_summaries_meeting_id ON summaries(meeting_id);
CREATE INDEX IF NOT EXISTS idx_summaries_summary_type ON summaries(summary_type);



/*
  # Action Items

  1. New Tables
    - `action_items`
      - `id` (uuid, primary key)
      - `meeting_id` (uuid, references meetings)
      - `title` (text)
      - `description` (text)
      - `assignee` (text)
      - `assignee_email` (text)
      - `due_date` (date)
      - `priority` (text) - 'low', 'medium', 'high', 'urgent'
      - `status` (text) - 'pending', 'in_progress', 'completed', 'cancelled'
      - `completed_at` (timestamp)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `action_items` table
    - Add policies based on meeting ownership
*/

-- Create action_items table
CREATE TABLE IF NOT EXISTS action_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  meeting_id uuid REFERENCES meetings(id) ON DELETE CASCADE NOT NULL,
  title text NOT NULL,
  description text DEFAULT '',
  assignee text,
  assignee_email text,
  due_date date,
  priority text DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'cancelled')),
  completed_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE action_items ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view action items of own meetings"
  ON action_items
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = action_items.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create action items for own meetings"
  ON action_items
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = action_items.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update action items of own meetings"
  ON action_items
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = action_items.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

-- Create updated_at trigger
CREATE TRIGGER update_action_items_updated_at
  BEFORE UPDATE ON action_items
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create function to automatically set completed_at when status changes to completed
CREATE OR REPLACE FUNCTION handle_action_item_completion()
RETURNS trigger AS $$
BEGIN
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    NEW.completed_at = now();
  ELSIF NEW.status != 'completed' THEN
    NEW.completed_at = NULL;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_action_item_status_change
  BEFORE UPDATE ON action_items
  FOR EACH ROW
  EXECUTE FUNCTION handle_action_item_completion();

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_action_items_meeting_id ON action_items(meeting_id);
CREATE INDEX IF NOT EXISTS idx_action_items_status ON action_items(status);
CREATE INDEX IF NOT EXISTS idx_action_items_due_date ON action_items(due_date);
CREATE INDEX IF NOT EXISTS idx_action_items_assignee_email ON action_items(assignee_email);


/*
  # Sentiment Analysis

  1. New Tables
    - `sentiment_analysis`
      - `id` (uuid, primary key)
      - `meeting_id` (uuid, references meetings)
      - `overall_sentiment` (text) - 'positive', 'neutral', 'negative'
      - `sentiment_score` (decimal) - -1.0 to 1.0
      - `participant_sentiments` (jsonb) - per-participant sentiment data
      - `sentiment_timeline` (jsonb) - sentiment changes over time
      - `engagement_score` (decimal) - 0.0 to 1.0
      - `conflict_detected` (boolean)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `sentiment_analysis` table
    - Add policies based on meeting ownership
*/

-- Create sentiment_analysis table
CREATE TABLE IF NOT EXISTS sentiment_analysis (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  meeting_id uuid REFERENCES meetings(id) ON DELETE CASCADE NOT NULL,
  overall_sentiment text DEFAULT 'neutral' CHECK (overall_sentiment IN ('positive', 'neutral', 'negative')),
  sentiment_score decimal(3,2) DEFAULT 0.0 CHECK (sentiment_score >= -1.0 AND sentiment_score <= 1.0),
  participant_sentiments jsonb DEFAULT '{}'::jsonb,
  sentiment_timeline jsonb DEFAULT '[]'::jsonb,
  engagement_score decimal(3,2) DEFAULT 0.0 CHECK (engagement_score >= 0.0 AND engagement_score <= 1.0),
  conflict_detected boolean DEFAULT false,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE sentiment_analysis ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view sentiment analysis of own meetings"
  ON sentiment_analysis
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = sentiment_analysis.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create sentiment analysis for own meetings"
  ON sentiment_analysis
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = sentiment_analysis.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update sentiment analysis of own meetings"
  ON sentiment_analysis
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = sentiment_analysis.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

-- Create updated_at trigger
CREATE TRIGGER update_sentiment_analysis_updated_at
  BEFORE UPDATE ON sentiment_analysis
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_sentiment_analysis_meeting_id ON sentiment_analysis(meeting_id);
CREATE INDEX IF NOT EXISTS idx_sentiment_analysis_overall_sentiment ON sentiment_analysis(overall_sentiment);



/*
  # Meeting Participants

  1. New Tables
    - `meeting_participants`
      - `id` (uuid, primary key)
      - `meeting_id` (uuid, references meetings)
      - `name` (text)
      - `email` (text)
      - `role` (text) - 'host', 'participant', 'observer'
      - `join_time` (timestamp)
      - `leave_time` (timestamp)
      - `speaking_time_seconds` (integer)
      - `participation_score` (decimal)
      - `created_at` (timestamp)

  2. Security
    - Enable RLS on `meeting_participants` table
    - Add policies based on meeting ownership
*/

-- Create meeting_participants table
CREATE TABLE IF NOT EXISTS meeting_participants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  meeting_id uuid REFERENCES meetings(id) ON DELETE CASCADE NOT NULL,
  name text NOT NULL,
  email text,
  role text DEFAULT 'participant' CHECK (role IN ('host', 'participant', 'observer')),
  join_time timestamptz,
  leave_time timestamptz,
  speaking_time_seconds integer DEFAULT 0,
  participation_score decimal(3,2) DEFAULT 0.0 CHECK (participation_score >= 0.0 AND participation_score <= 1.0),
  created_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE meeting_participants ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view participants of own meetings"
  ON meeting_participants
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = meeting_participants.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can add participants to own meetings"
  ON meeting_participants
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = meeting_participants.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update participants of own meetings"
  ON meeting_participants
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM meetings 
      WHERE meetings.id = meeting_participants.meeting_id 
      AND meetings.user_id = auth.uid()
    )
  );

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_meeting_participants_meeting_id ON meeting_participants(meeting_id);
CREATE INDEX IF NOT EXISTS idx_meeting_participants_email ON meeting_participants(email);



/*
  # User Integrations

  1. New Tables
    - `user_integrations`
      - `id` (uuid, primary key)
      - `user_id` (uuid, references user_profiles)
      - `integration_type` (text) - 'slack', 'email', 'calendar', 'notion', etc.
      - `integration_name` (text)
      - `config` (jsonb) - integration-specific configuration
      - `access_token` (text) - encrypted access token
      - `refresh_token` (text) - encrypted refresh token
      - `is_active` (boolean)
      - `last_sync` (timestamp)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `user_integrations` table
    - Add policies for users to manage their own integrations
*/

-- Create user_integrations table
CREATE TABLE IF NOT EXISTS user_integrations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL,
  integration_type text NOT NULL CHECK (integration_type IN ('slack', 'email', 'google_calendar', 'outlook', 'notion', 'zoom', 'teams')),
  integration_name text NOT NULL,
  config jsonb DEFAULT '{}'::jsonb,
  access_token text, -- Should be encrypted in production
  refresh_token text, -- Should be encrypted in production
  is_active boolean DEFAULT true,
  last_sync timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE user_integrations ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view own integrations"
  ON user_integrations
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create own integrations"
  ON user_integrations
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own integrations"
  ON user_integrations
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own integrations"
  ON user_integrations
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

-- Create updated_at trigger
CREATE TRIGGER update_user_integrations_updated_at
  BEFORE UPDATE ON user_integrations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_user_integrations_user_id ON user_integrations(user_id);
CREATE INDEX IF NOT EXISTS idx_user_integrations_type ON user_integrations(integration_type);
CREATE UNIQUE INDEX IF NOT EXISTS idx_user_integrations_unique ON user_integrations(user_id, integration_type, integration_name);



/*
  # User Analytics and Usage

  1. New Tables
    - `user_analytics`
      - `id` (uuid, primary key)
      - `user_id` (uuid, references user_profiles)
      - `total_meetings` (integer)
      - `total_duration_minutes` (integer)
      - `total_transcription_minutes` (integer)
      - `avg_meeting_duration` (decimal)
      - `avg_participants_per_meeting` (decimal)
      - `productivity_score` (decimal)
      - `last_meeting_date` (date)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

    - `daily_usage`
      - `id` (uuid, primary key)
      - `user_id` (uuid, references user_profiles)
      - `date` (date)
      - `meetings_count` (integer)
      - `total_duration_minutes` (integer)
      - `transcription_minutes` (integer)
      - `action_items_created` (integer)
      - `created_at` (timestamp)

  2. Security
    - Enable RLS on both tables
    - Add policies for users to view their own analytics
*/

-- Create user_analytics table
CREATE TABLE IF NOT EXISTS user_analytics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL UNIQUE,
  total_meetings integer DEFAULT 0,
  total_duration_minutes integer DEFAULT 0,
  total_transcription_minutes integer DEFAULT 0,
  avg_meeting_duration decimal(8,2) DEFAULT 0.0,
  avg_participants_per_meeting decimal(4,2) DEFAULT 0.0,
  productivity_score decimal(3,2) DEFAULT 0.0 CHECK (productivity_score >= 0.0 AND productivity_score <= 1.0),
  last_meeting_date date,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Create daily_usage table
CREATE TABLE IF NOT EXISTS daily_usage (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL,
  date date NOT NULL,
  meetings_count integer DEFAULT 0,
  total_duration_minutes integer DEFAULT 0,
  transcription_minutes integer DEFAULT 0,
  action_items_created integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  UNIQUE(user_id, date)
);

-- Enable RLS
ALTER TABLE user_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_usage ENABLE ROW LEVEL SECURITY;

-- Create policies for user_analytics
CREATE POLICY "Users can view own analytics"
  ON user_analytics
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "System can manage analytics"
  ON user_analytics
  FOR ALL
  TO service_role
  USING (true);

-- Create policies for daily_usage
CREATE POLICY "Users can view own daily usage"
  ON daily_usage
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "System can manage daily usage"
  ON daily_usage
  FOR ALL
  TO service_role
  USING (true);

-- Create updated_at trigger for user_analytics
CREATE TRIGGER update_user_analytics_updated_at
  BEFORE UPDATE ON user_analytics
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create function to update analytics when meetings change
CREATE OR REPLACE FUNCTION update_user_analytics()
RETURNS trigger AS $$
BEGIN
  -- Update or insert user analytics
  INSERT INTO user_analytics (user_id, total_meetings, total_duration_minutes, last_meeting_date)
  SELECT 
    NEW.user_id,
    COUNT(*),
    COALESCE(SUM(duration_minutes), 0),
    MAX(start_time::date)
  FROM meetings 
  WHERE user_id = NEW.user_id AND status = 'completed'
  ON CONFLICT (user_id) 
  DO UPDATE SET
    total_meetings = EXCLUDED.total_meetings,
    total_duration_minutes = EXCLUDED.total_duration_minutes,
    avg_meeting_duration = CASE 
      WHEN EXCLUDED.total_meetings > 0 THEN EXCLUDED.total_duration_minutes::decimal / EXCLUDED.total_meetings 
      ELSE 0 
    END,
    last_meeting_date = EXCLUDED.last_meeting_date,
    updated_at = now();

  -- Update daily usage
  INSERT INTO daily_usage (user_id, date, meetings_count, total_duration_minutes)
  VALUES (
    NEW.user_id,
    NEW.start_time::date,
    1,
    COALESCE(NEW.duration_minutes, 0)
  )
  ON CONFLICT (user_id, date)
  DO UPDATE SET
    meetings_count = daily_usage.meetings_count + 1,
    total_duration_minutes = daily_usage.total_duration_minutes + COALESCE(NEW.duration_minutes, 0);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for meeting completion
CREATE TRIGGER on_meeting_completed
  AFTER UPDATE ON meetings
  FOR EACH ROW
  WHEN (NEW.status = 'completed' AND OLD.status != 'completed')
  EXECUTE FUNCTION update_user_analytics();

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_user_analytics_user_id ON user_analytics(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_usage_user_id ON daily_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_usage_date ON daily_usage(date);



/*
  # User Subscriptions and Billing

  1. New Tables
    - `subscriptions`
      - `id` (uuid, primary key)
      - `user_id` (uuid, references user_profiles)
      - `plan_type` (text) - 'starter', 'professional', 'enterprise'
      - `status` (text) - 'active', 'cancelled', 'past_due', 'trialing'
      - `current_period_start` (timestamp)
      - `current_period_end` (timestamp)
      - `trial_end` (timestamp)
      - `stripe_customer_id` (text)
      - `stripe_subscription_id` (text)
      - `monthly_meeting_limit` (integer)
      - `monthly_meetings_used` (integer)
      - `created_at` (timestamp)
      - `updated_at` (timestamp)

  2. Security
    - Enable RLS on `subscriptions` table
    - Add policies for users to view their own subscription
*/

-- Create subscriptions table
CREATE TABLE IF NOT EXISTS subscriptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL UNIQUE,
  plan_type text DEFAULT 'starter' CHECK (plan_type IN ('starter', 'professional', 'enterprise')),
  status text DEFAULT 'trialing' CHECK (status IN ('active', 'cancelled', 'past_due', 'trialing', 'incomplete')),
  current_period_start timestamptz DEFAULT now(),
  current_period_end timestamptz DEFAULT (now() + interval '1 month'),
  trial_end timestamptz DEFAULT (now() + interval '14 days'),
  stripe_customer_id text,
  stripe_subscription_id text,
  monthly_meeting_limit integer DEFAULT 5,
  monthly_meetings_used integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view own subscription"
  ON subscriptions
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "System can manage subscriptions"
  ON subscriptions
  FOR ALL
  TO service_role
  USING (true);

-- Create updated_at trigger
CREATE TRIGGER update_subscriptions_updated_at
  BEFORE UPDATE ON subscriptions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create function to initialize subscription for new users
CREATE OR REPLACE FUNCTION handle_new_user_subscription()
RETURNS trigger AS $$
BEGIN
  INSERT INTO subscriptions (user_id, plan_type, status, monthly_meeting_limit)
  VALUES (NEW.id, 'starter', 'trialing', 5);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for new user subscription
CREATE TRIGGER on_user_profile_created
  AFTER INSERT ON user_profiles
  FOR EACH ROW
  EXECUTE FUNCTION handle_new_user_subscription();

-- Create function to check meeting limits
CREATE OR REPLACE FUNCTION check_meeting_limit()
RETURNS trigger AS $$
DECLARE
  current_usage integer;
  meeting_limit integer;
  subscription_status text;
BEGIN
  -- Get current usage and limit
  SELECT 
    monthly_meetings_used, 
    monthly_meeting_limit,
    status
  INTO current_usage, meeting_limit, subscription_status
  FROM subscriptions 
  WHERE user_id = NEW.user_id;

  -- Check if user has exceeded limit (only for non-enterprise plans)
  IF subscription_status = 'active' AND meeting_limit > 0 AND current_usage >= meeting_limit THEN
    RAISE EXCEPTION 'Monthly meeting limit exceeded. Please upgrade your plan.';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to check limits before creating meetings
CREATE TRIGGER check_meeting_limit_trigger
  BEFORE INSERT ON meetings
  FOR EACH ROW
  EXECUTE FUNCTION check_meeting_limit();

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
CREATE INDEX IF NOT EXISTS idx_subscriptions_stripe_customer_id ON subscriptions(stripe_customer_id);



/*
  # Contact Forms and Demo Requests

  1. New Tables
    - `contact_submissions`
      - `id` (uuid, primary key)
      - `name` (text)
      - `email` (text)
      - `company` (text)
      - `job_title` (text)
      - `inquiry_type` (text)
      - `subject` (text)
      - `message` (text)
      - `status` (text) - 'new', 'in_progress', 'resolved'
      - `created_at` (timestamp)

    - `demo_requests`
      - `id` (uuid, primary key)
      - `first_name` (text)
      - `last_name` (text)
      - `email` (text)
      - `company` (text)
      - `job_title` (text)
      - `team_size` (text)
      - `use_case` (text)
      - `preferred_date` (date)
      - `preferred_time` (text)
      - `questions` (text)
      - `status` (text) - 'pending', 'scheduled', 'completed', 'cancelled'
      - `created_at` (timestamp)

  2. Security
    - Enable RLS on both tables
    - Allow public inserts for form submissions
    - Restrict reads to service role only
*/

-- Create contact_submissions table
CREATE TABLE IF NOT EXISTS contact_submissions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  email text NOT NULL,
  company text,
  job_title text,
  inquiry_type text DEFAULT 'general' CHECK (inquiry_type IN ('general', 'sales', 'support', 'partnership', 'press', 'careers')),
  subject text NOT NULL,
  message text NOT NULL,
  status text DEFAULT 'new' CHECK (status IN ('new', 'in_progress', 'resolved')),
  created_at timestamptz DEFAULT now()
);

-- Create demo_requests table
CREATE TABLE IF NOT EXISTS demo_requests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  first_name text NOT NULL,
  last_name text NOT NULL,
  email text NOT NULL,
  company text NOT NULL,
  job_title text,
  team_size text,
  use_case text,
  preferred_date date,
  preferred_time text,
  questions text,
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'scheduled', 'completed', 'cancelled')),
  created_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE contact_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE demo_requests ENABLE ROW LEVEL SECURITY;

-- Create policies for contact_submissions
CREATE POLICY "Anyone can submit contact forms"
  ON contact_submissions
  FOR INSERT
  TO anon, authenticated
  WITH CHECK (true);

CREATE POLICY "Service role can manage contact submissions"
  ON contact_submissions
  FOR ALL
  TO service_role
  USING (true);

-- Create policies for demo_requests
CREATE POLICY "Anyone can submit demo requests"
  ON demo_requests
  FOR INSERT
  TO anon, authenticated
  WITH CHECK (true);

CREATE POLICY "Service role can manage demo requests"
  ON demo_requests
  FOR ALL
  TO service_role
  USING (true);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_contact_submissions_email ON contact_submissions(email);
CREATE INDEX IF NOT EXISTS idx_contact_submissions_status ON contact_submissions(status);
CREATE INDEX IF NOT EXISTS idx_contact_submissions_created_at ON contact_submissions(created_at);

CREATE INDEX IF NOT EXISTS idx_demo_requests_email ON demo_requests(email);
CREATE INDEX IF NOT EXISTS idx_demo_requests_status ON demo_requests(status);
CREATE INDEX IF NOT EXISTS idx_demo_requests_created_at ON demo_requests(created_at);



/*
  # Views and Helper Functions

  1. Views
    - `user_dashboard_stats` - Dashboard statistics for users
    - `recent_meetings_with_details` - Recent meetings with related data
    - `meeting_analytics` - Meeting analytics and insights

  2. Functions
    - `get_user_meeting_stats` - Get comprehensive meeting statistics
    - `search_meetings` - Full-text search across meetings
    - `get_action_items_summary` - Get action items summary
*/

-- Create view for user dashboard stats
CREATE OR REPLACE VIEW user_dashboard_stats AS
SELECT 
  up.id as user_id,
  up.first_name,
  up.last_name,
  up.company,
  s.plan_type,
  s.status as subscription_status,
  ua.total_meetings,
  ua.total_duration_minutes,
  ua.productivity_score,
  ua.last_meeting_date,
  s.monthly_meetings_used,
  s.monthly_meeting_limit,
  (
    SELECT COUNT(*) 
    FROM action_items ai 
    JOIN meetings m ON ai.meeting_id = m.id 
    WHERE m.user_id = up.id AND ai.status = 'pending'
  ) as pending_action_items,
  (
    SELECT COUNT(*) 
    FROM meetings m 
    WHERE m.user_id = up.id 
    AND m.created_at >= date_trunc('week', now())
  ) as meetings_this_week
FROM user_profiles up
LEFT JOIN subscriptions s ON up.id = s.user_id
LEFT JOIN user_analytics ua ON up.id = ua.user_id;

-- Create view for recent meetings with details
CREATE OR REPLACE VIEW recent_meetings_with_details AS
SELECT 
  m.id,
  m.user_id,
  m.title,
  m.description,
  m.status,
  m.start_time,
  m.end_time,
  m.duration_minutes,
  m.participant_count,
  m.created_at,
  t.content as transcript_content,
  t.confidence_score,
  s.summary_text,
  (
    SELECT COUNT(*) 
    FROM action_items ai 
    WHERE ai.meeting_id = m.id
  ) as action_items_count,
  (
    SELECT COUNT(*) 
    FROM action_items ai 
    WHERE ai.meeting_id = m.id AND ai.status = 'completed'
  ) as completed_action_items,
  sa.overall_sentiment,
  sa.engagement_score
FROM meetings m
LEFT JOIN transcripts t ON m.id = t.meeting_id
LEFT JOIN summaries s ON m.id = s.meeting_id
LEFT JOIN sentiment_analysis sa ON m.id = sa.meeting_id
ORDER BY m.created_at DESC;

-- Create function to get user meeting stats
CREATE OR REPLACE FUNCTION get_user_meeting_stats(user_uuid uuid)
RETURNS TABLE (
  total_meetings bigint,
  total_duration_hours decimal,
  avg_meeting_duration decimal,
  meetings_this_month bigint,
  action_items_created bigint,
  action_items_completed bigint,
  avg_sentiment_score decimal,
  top_meeting_day text
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(m.id) as total_meetings,
    ROUND(COALESCE(SUM(m.duration_minutes), 0) / 60.0, 2) as total_duration_hours,
    ROUND(COALESCE(AVG(m.duration_minutes), 0), 2) as avg_meeting_duration,
    COUNT(CASE WHEN m.created_at >= date_trunc('month', now()) THEN 1 END) as meetings_this_month,
    (
      SELECT COUNT(*) 
      FROM action_items ai 
      JOIN meetings m2 ON ai.meeting_id = m2.id 
      WHERE m2.user_id = user_uuid
    ) as action_items_created,
    (
      SELECT COUNT(*) 
      FROM action_items ai 
      JOIN meetings m2 ON ai.meeting_id = m2.id 
      WHERE m2.user_id = user_uuid AND ai.status = 'completed'
    ) as action_items_completed,
    ROUND(COALESCE(AVG(sa.sentiment_score), 0), 2) as avg_sentiment_score,
    (
      SELECT to_char(m3.start_time, 'Day')
      FROM meetings m3
      WHERE m3.user_id = user_uuid AND m3.start_time IS NOT NULL
      GROUP BY to_char(m3.start_time, 'Day')
      ORDER BY COUNT(*) DESC
      LIMIT 1
    ) as top_meeting_day
  FROM meetings m
  LEFT JOIN sentiment_analysis sa ON m.id = sa.meeting_id
  WHERE m.user_id = user_uuid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function for meeting search
CREATE OR REPLACE FUNCTION search_meetings(
  user_uuid uuid,
  search_query text,
  limit_count integer DEFAULT 10
)
RETURNS TABLE (
  meeting_id uuid,
  title text,
  start_time timestamptz,
  duration_minutes integer,
  summary_text text,
  relevance_score real
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id as meeting_id,
    m.title,
    m.start_time,
    m.duration_minutes,
    s.summary_text,
    ts_rank(
      to_tsvector('english', COALESCE(m.title, '') || ' ' || COALESCE(m.description, '') || ' ' || COALESCE(t.content, '') || ' ' || COALESCE(s.summary_text, '')),
      plainto_tsquery('english', search_query)
    ) as relevance_score
  FROM meetings m
  LEFT JOIN transcripts t ON m.id = t.meeting_id
  LEFT JOIN summaries s ON m.id = s.meeting_id
  WHERE m.user_id = user_uuid
  AND (
    to_tsvector('english', COALESCE(m.title, '') || ' ' || COALESCE(m.description, '') || ' ' || COALESCE(t.content, '') || ' ' || COALESCE(s.summary_text, ''))
    @@ plainto_tsquery('english', search_query)
  )
  ORDER BY relevance_score DESC, m.start_time DESC
  LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to get action items summary
CREATE OR REPLACE FUNCTION get_action_items_summary(user_uuid uuid)
RETURNS TABLE (
  total_action_items bigint,
  pending_items bigint,
  overdue_items bigint,
  completed_this_week bigint,
  upcoming_due_items bigint
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*) as total_action_items,
    COUNT(CASE WHEN ai.status = 'pending' THEN 1 END) as pending_items,
    COUNT(CASE WHEN ai.status = 'pending' AND ai.due_date < CURRENT_DATE THEN 1 END) as overdue_items,
    COUNT(CASE WHEN ai.status = 'completed' AND ai.completed_at >= date_trunc('week', now()) THEN 1 END) as completed_this_week,
    COUNT(CASE WHEN ai.status = 'pending' AND ai.due_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '7 days' THEN 1 END) as upcoming_due_items
  FROM action_items ai
  JOIN meetings m ON ai.meeting_id = m.id
  WHERE m.user_id = user_uuid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions to authenticated users
GRANT SELECT ON user_dashboard_stats TO authenticated;
GRANT SELECT ON recent_meetings_with_details TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_meeting_stats(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION search_meetings(uuid, text, integer) TO authenticated;
GRANT EXECUTE ON FUNCTION get_action_items_summary(uuid) TO authenticated;